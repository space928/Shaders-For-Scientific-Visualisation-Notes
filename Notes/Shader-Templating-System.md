# Shader Templating System

Users bind a shader to a render buffer:
```py
import pySSV as ssv
canvas = ssv.canvas()

shader = canvas.shader("""
// GLSL Shader code
""")
# More shaders can be defined on a canvas as long as they write to separate render buffers; we don't currently plan on supporting multiple draw calls per render buffer
# Although if we wanted to I guess the only thing that would change is that vertex buffers and uniforms would become associated with the shader and not the render buffer which might actually make more sense?
# shader1 = canvas.shader("//GLSL...", render_buffer=1)

canvas.run()
```

We need to take the user's glsl code and convert it to a valid glsl shader. Users should be able to build off of shader templates which could provide boilerplate code for things such as: sdf rendering, vertex shaders, etc... Uniforms and textures should be automatically declared for users. Users shouldn't need to know about the specifics of GLSL semantics (especially where these differ between platforms/compilers). Users shouldn't need to worry about specifying location attributes and shader stage inputs and outputs, these should be handled automatically; In OpenGL and DirectX shader stage in/outs are very different and quite confusing, especially since in older versions of OpenGL these are specified as `varying`s whereas in modern OpenGL these are now `in` and `out` variables.

Potential desired shader pipelines (*italics* indicate a stage is autogenerated):
 - Full screen fragment shader (similar to Shadertoy): 
   - *vertex* → **fragment**
 - Vertex shader (allows the use of a vertex shader for parallel processing of some vertices and then automatic rendering as points/lines/mesh): 
   - **vertex** → *fragment*
 - Vertex/fragment shader (for rendering custom meshes as the user pleases): 
   - **vertex** → **fragment**
 - Vertex/Geometry/Fragment shader:
   - **vertex** → **geometry** → **fragment**
 - Tesselation shader:
   - (Excluded for now unless someone has a compelling use)
   - **vertex** → **tess_control** → **tess_evaluation** → **fragment**
 - Compute shader:
   - **compute**
 - *More high-level templates*:
 - Vertex shader with advanced wireframe rendering:
   - **vertex** → *geometry* → *fragment*
 - SDF renderer (with options for isolines, volume rendering, etc...):
   - *vertex* → *fragment* + **distance_function[]**
 - Line renderer (2D/3D graphing)?
 - Material surface shaders (similar to Unity)?
 - User defined templates?

Of this list the first two options are somewhat special cases as the varyings between shader stages would be predetermined by the template, in other cases the user needs to be able to define them themselves.

A user might want to write a shader like this:
```glsl
#pragma SSV pixel frag
// The entrypoint to the fragment shader
vec4 frag(v2f_quad input)
{
    vec2 uv = input.fragPos.xy / uResolution.xy;
    
    return mix(uv.xyx, uv.yyx, sin(uTime)*0.5+0.5);
}
```

It would be nice if the preprocessor code was independent of the shader templates; adding a new shader template should be possible without having to modify the preprocessor code. This would also allow user defined templates.

Built in templates would be searched for when invoked by the user's `#pragma SSV` command. Eg: `#pragma SSV pixel frag` would create a new shader based on the template `template_pixel.glsl`.

A shader template might look like:
```glsl
#pragma SSVTemplate define shadertoy
#pragma SSVTemplate stage vertex 
#pragma SSVTemplate stage fragment 
// Arguments get converted into compiler defines by the preprocessor
// an argument's name is transformed to match our naming convention:
//    entrypoint -> T_ENTRYPOINT
//    _varying_struct -> T_VARYING_STRUCT
#pragma SSVTemplate arg entrypoint
// Prefixing an argument name with an underscore is shorthand for --non_positional
// #pragma SSVTemplate arg _varying_struct --type str
// An example for an SDF shader
// #pragma SSVTemplate arg _render_mode --choices solid xray isolines 2d

#ifdef _GL_VERSION
#version _GL_VERSION 
// For some compilers you need to specify the OpenGL version to target as the first line of the shader.
#endif // _GL_VERSION
#ifdef _GL_PRECISION
// In OpenGL ES you need to specify the precision of variables, you can do this per-variable or specify a default.
// https://stackoverflow.com/a/6336285
precision highp float;
#endif // _GL_PRECISION

#define SHADERTOY_COMPAT
// Include any default includes we think the user might want
#include "global_uniforms.glsl" 


#ifdef SHADER_STAGE_VERTEX
in vec2 in_vert;
in vec3 in_color;
out vec3 color;
out vec2 position;
void main() {
    gl_Position = vec4(in_vert, 0.0, 1.0);
    color = in_color;
    position = in_vert*0.5+0.5;
}
#endif //SHADER_STAGE_VERTEX


#ifdef SHADER_STAGE_FRAGMENT
out vec4 fragColor;
in vec3 color;
in vec2 position;

#include "TEMPLATE_DATA"
        
void main() {
    // Not using the color attribute causes the compiler to strip it and confuses modernGL.
    fragColor = mainImage(position * iResolution) + vec4(color, 1.0)*1e-6;
}
#endif //SHADER_STAGE_FRAGMENT

```

So given the user's shader preprocessor would do the following:
1. Run a minimal (`#pragma` only) preprocessor to find the `#pragma SSV templateName args...` definition. Removing the pragma from the source code once it's done but not expanding any macros.
2. Using this search for the appropriate template (`template_templateName.glsl`).
3. Run the same minimal preprocessor on the template to determine how to parse the arguments.
4. Setup argparse and run it on the additional arguments passed in the first `#pragma SSV`.
5. Pass the parsed arguments in as preprocessor defines to the template preprocessor.
6. Preprocess the shader template for each of the required shader stages.
7. You now have fully processed shaders for each stage of the pipeline!
